# Ricardo's Resource-based voting platform

## Who am I?
I'm Ricardo Almeida, a 3rd year PhD student from the University of Pisa and University of Camerino, both in Italy. I'm on my last year of a National PhD Program on Blockchain and Distributed Ledger Technology, the first of its kind in Italy. My research has been primarily centred on remove voting systems, i.e., voting platforms that do not restrict voters geographically, but recently I was able to "convince" my advisors to switch the base technology in which I'm exploring this concept towards the resource-based paradigm exhibited by smart contract programming languages such as Cadence and Move.

The concept in itself is equally exciting and unexplored and I decided to kill two birds in one stone by exploring it from the point of view of a voting platform. I've been programming and exploring the Flow blockchain and Cadence since early 2022. I was extremely curious and attracted by how radical the resource-based paradigm was when compared to the "traditional" way of representing digital assets in a blockchain context, which is essentially the mapping-based strategy employed in Solidity and related languages. The resource paradigm was far cleaner, secure and so, so much fun to work with when compared to Solidity. I've been trying to "sell" this to my advisor team since then, but unfortunately I had to wait for the rest of the research community to catch on to get any traction worth mentioning.

## What am I working in right now?
One day my main advisor requested a meeting with me. She had went to an academic conference in 2024 (somewhere in Europe, don't remember exactly where) and it turned out that Move and resources were all the rage in there. There were a lot of articles being presented over the topic and she could see that this paradigm was finally seeping into the academic world. Even though she was only half paying attention whenever I was explaining how Flow and Cadence worked, she understood enough to realise that one of her own students was looking at this for a full 2 years up to that point. Now I look like this visionary, but I had to eat a lot of crow before getting vindicated.

Currently, my researched has shifted towards providing a full analysis of the resource-based concept:
- Where did it came from?
- How does it work exactly?
- Who's using it?
- What are the advantages and disadvantages over the ledger-based (e.g. Ethereum) "classical" model?

I'm working on this alongside with the development of the first resource-based remote voting platform, which I obviously want to develop in Cadence and Flow.

# The Resource-based Voting Platform
(I don't have a cool name for it yet... :confused:)

The basis of my idea is summarised in the figure bellow:

<img width="905" height="844" alt="15_Resource_based_enc_framework" src="https://github.com/user-attachments/assets/4345bb2c-45b5-4c9c-8f8e-c80359147dd7" />

From the point of view of other remote voting systems, even blockchain-based ones, there's not a lot added to this approach, given that it is a tried and successful one. The biggest addition from my part is to use resources to abstract ballots as a way to research how these can fare in such context.

**NOTE:** From this point onwards, for simplicity sake, I'm referring to any resource instance in a capitalised fashion. A "Ballot" refers to an instance of a Cadence resource defined through a smart contract and minted using the usual admin-type resource. A "ballot" on the other hand refers to the general object.

The star of this system is the Ballot resource. I've build this one to emulate a real world ballot as much as possible (given than resources are inspired by *linear types* and these intend to represent real-world values as well). Just like with real-life ballots, Ballot's ownership is implied from the account owner whose storage they exist at any point.
Ballots are printed on demand by an authority (The *Election Authority (EA)* in the figure) and delivered to the voter's account upon successful registration/authentication. This emulates a physical voting booth where a voter gets a paper ballot printed by the election organisers after these check that the voter's ID is an eligibility list.

## System Actors:
- **Voter $$V$$:** The main actor in the system. The registration process gets the voters identification $$Id_{V}$$, the account address $$V_{A}$$ and inserts this pair in the eligibility list, if validated through whatever rules $$EA$$ wishes to impose.
- **Voter Device $$D$$** Some operations in this system need to happen off chain. The voter device abstracts the platform used for this purpose. This device can be any kind of computation platform capable of basic cryptographic operations, mainly, calculating hash digests, encrypt and decrypt data. Cadence is capable of running hashing algorithms but not encryption/decryption ones. A mobile phone or a laptop is more than capable of the kind of operations that I need done. This is not a technological limitation but has everything to do with the fact that Flow is a public blockchain, therefore all data on chain is available for public consultation. Performing encryptions and decryptions in public blockchains is highly unadvisable since it is impossible to do such operation without revealing the sensible information, such as the plaintext to encrypt and any private encryption keys involved (they are called "private" for a reason :no_mouth:). Therefore I need some of this process to happen outside of the Flow chain and in a device capable of running the kind of computations indicated.
- **Election Authority $$EA$$** Also known as the election administrator, this entity is responsible to create and distribute encryption keys, validate voter's eligibility, mint new Ballots and compute tallies. Half of the proposed process happens between Flow accounts. On one side I have the voter's individual accounts, and on the other I have $$EA$$'s own account, which is going to be used to store the critical resources for this exercise, namely, the BallotPrinterAdmin and Elections (more on this in a minute).

## Smart Contract Backend
The bulk of the logic suggested is going to be processed through a smart contract backend. But in this resource-based context, smart contracts are more akin to recipe books for resources than logic units, as it is the case for ledger-based blockchains. As such, the contracts deployed in this project are used as standards to create the resources that this process depends on. These are:
- The *BallotStandard* contract that implements the details for Ballots.
- The *ElectionStandard* contract that implements the details for Elections.
- The *VotingBooth* contract (used to define, create, and save the *BallotPrinterAdmin*. Check [this section](#process-resources) for additional details)
- The *BallotBurner* contract to create a *BurnBox* resource to allow voters to set unwanted Ballots to be burn (I'm still figuring out if I really need this resource or not :neutral_face:)

## System Resources
The basis of this system hinges on the following set of resources:
- **Ballot** As I've mentioned before, the Ballot resource is the base element. Its minting is highly regulated by the usual admin printer resource, as it has been the case for most resource based contracts in the Flow blockchain. As resource, Ballots are fairly simple since they intend to transport the choice of a voter $$V$$ throughout the system. They work as mutable NFTs, which is not a usual concept in ledger-based blockchain, but it is trivial to implement in a resource based one. The advanced access control system offered by Cadence allows me to build these resources so that only the voter can edit the *option* parameter in their metadata and so that they don't leak any information during the process. Unfortunately, Flow is still a public blockchain and there are no access control strategy that I can use to completely prevent anyone from reading the information in a Ballot. At the end of the day, all Ballot data goes into the blockchain and can be publicly consulted by checking the block data itself. As such, I have to conceive this system in such a way that voting data never gets into a Ballot as plaintext. More details on this further on.
- **BallotPrinterAdmin** This one is the usual "NFT" printer and it follows the Cadence convention: this resource is created once and only once during the *VoteBooth* contract deployment, and it is immediately stored into the *Election Authority (EA)* account. This means that only the *EA* can run the *printBallot* function to issue a blank Ballot to a given voter $$V$$. All the logic to create *BallotPrinterAdmin* resources is contained in the *VoteBooth* contract constructor, as it is the usual case.
- **Election** This resource is used to abstract a single election exercise. The idea is to establish this system as a modular one, capable of running multiple elections in parallel. The way to do it is to encapsulate the whole exercise in an Election resource. Election creation is limited to the *Election Authority* but since these are not supposed to be saved in any account other than *EA's*, there's no need to create a minter resource for these ones (though I'm still researching if using an *ElectionMinter* of sorts could be a more practical approach...). Each Election is characterised by an unique id value $$Id_{E}$$, an *electionName*, an *electionBallot* that contains the question to be answered by the voter, and an *electionOptions* set displaying the options available for the voter to chose from. Elections are, to some extend, *Collection-type* resources that can hold other resources, namely, Ballots. They do so through the usual dictionary, but in this case I'm using the hash digest of the voters identification string $$Id_{V_{i}}$$ as key, thus storing the Ballots submitted by voters in a fairly private manner (realistically, if the voter leaks his/her identification string, an adversary can use that to retrieve the voter's Ballot information. The actual choice in that Ballot is still protected with encryption, but this possibility does affect the privacy of the voter in a non insignificant amount). Elections emulate mail boxes in regards to how they store Ballots. I'm using Cadence access control primitives to limit the withdrawal of submitted Ballots to the *Election Authority* alone, this mimicking a regular mailbox: anyone can deposit a letter into it, but once you do, only the mailman with the proper key can withdraw it.
- **VoteBox** This is a *Collection-type* resource that lives in each valid voter's storage account. It is used to simplify the deposit and withdrawal of Ballots from an individual user's storage account. Also, I'm using Cadence advanced programmatic capabilities to extend the functionalities of the account itself by adding the auxiliary functions that I need to this resource. *VoteBoxes* are created into a voter's account storage upon successful registration beneath the *Election Authority*. *VoteBoxes* store blank and filled (but not submitted yet) Ballots in an internal dictionary that uses the id of the Election that those Ballots are to be used with as key. This by itself limits *VoteBoxes* to store one and only one Ballot per Election, which is a easy and practical way to prevent double voting.

## Voting Process
I'm going to describe the expected voting process, as indicated in [the figure](#the-resource-based-voting-platform). The figure is self-explanatory but it is important to add that every state transition is indicated by an arrow and it is implemented in the system using Cadence transactions.

1. The voting process begins with a voter registering him/herself with the *Election Authority (EA)*. If deemed eligible, *EA* adds the voter information to its own internal database. Due to privacy concerns, this process occurs off chain. The actual details of the registration process depend on the policies and rules that the *EA* wishes to implement, but in principle, voters only need to register once and then use the authentication process to participate in various elections. A successful registration concludes with the creation and saving of a *VoteBox* in the voter's storage account. The *EA* proceeds by creating individual Elections and publishing their details, namely, the $$Id_{E_{j}}$$, the *electionName*, *electionBallot*, and *electionOptions* to inform voters of ongoing elections. A voter $$V_{i}$$ use the tuple $$(V_{A_{i}}, Id_{V_{i}}, Id_{E_{j}})$$, i.e., the voter account address, his/her identification string, and the id of the Election that the voter wishes to participate, to authenticate him/herself and request a Ballot to vote in Election $$Id_{E_{j}}$$. Voters use their *voting device* $$D_{i}$$ to interact with the *VoteBox* in their account's storage to execute the authentication operation.
2. If a voter is deemed eligible to vote in a given Election $$Id_{E_{j}}$$, the *EA* proceeds by providing the tuple $$(V_{A_{i}}, Id_{E_{j}}, pk)$$ to the *BallotPrinterAdmin* that only *EA* can interact with. The *BallotPrinterAdmin* mints a blank Ballot $$B_{Id_{B}, Id_{E_{j}}}$$, where $$Id_{B}$$ is the unique identifier for the minted Ballot, and $$Id_{E_{j}}$$ identifies a specific existing Election where this Ballot can be cast to. Every Ballot is minted "locked" to a specific Election, which means that it can only be used with the Election identified by $$Id_{E_{j}}$$. Ballots are relatively cheap to produce in Flow, so it this strategy is feasible and produces a highly secure system, albeit a bit strict in some sense.
3. The *BallotPrinterAdmin* uses the voter address $$V_{A_{i}}$$ provided to deposit the Ballot $$B_{Id_{B}, Id_{E_{j}}}$$ into voter $$V_{i}$$ *VoteBox*. This deposit is conditional. If it turns out that the voter's *VoteBox* already has a Ballot stored under the $$Id_{E_{j}}$$ key, the transaction fails and the blockchain state reverts. To avoid unnecessary creation of Ballots, the *BallotPrinterAdmin* checks the voter's *VoteBox* first, to see if there's a Ballot in there under the provided $$Id_{E_{j}}$$. If one exists already, the transaction fails before a new Ballot is minted.
4. With a blank Ballot in his/her possession, the voter can now vote. But given that his/her choice needs to be encrypted first, the voter choses a valid option in his/her *voting device* screen (I'm imagining this as a mobile application) and the *voting device* does the rest. The Ballot with provided with a *public encryption key (pk)* created and set upon the Election in question by the *EA*. The *voting device* uses this key to obfuscate the option selected by the voter. But since each Election has a finite (and usually small) set of available options, to protect the voter's privacy, I need to add some *salt* to the encryption, or otherwise it's easy for an adversary to figure out which option a voter has selected if there's only a finite number of ciphertexts submitted in each Election. To that effect, the *voting device* generates a random integer $$r$$ and concatenates it with the selected option to increase the space of the ciphertext and thus protect the voter's privacy. This *salt* can and it is used later in the process as a "tally receipt" to increase the transparency of this process. Details on this receipt process follow shortly.
5. Once a valid option string is produced by the *voting device*, it continues by setting the Ballot metadata, namely a specific mutable option field, to this choice string. Because this process changes the state of the blockchain, it requires a transaction as well.
6. The Ballot is now ready for submission. The 2 previous points can be repeated by the voter if he/she changes his/her mind before submitting the Ballot, i.e., the voter can edit the Ballot's metadata as many times he/she wishes until it gets submitted. Submitting a Ballot means depositing it in an Election's internal dictionary (identified in the [figure](#the-resource-based-voting-platform) as the *ballots* dictionary). Once submitted, the Ballot become irrecoverable by the voter. It can be revoked or replaced by another one (details on this to follow as well), but once a Ballot goes into the *ballots* dictionary of an Election, it can only be withdrawn by the *Election Authority* during the tally process.
7. 


### Ballot Revoking
TODO

### Multiple Ballot Casting
TODO

# What is my "Real" Objective with this Project?
POD stuff