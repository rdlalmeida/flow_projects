# Ricardo's resource-based voting platform

## Who am I?
I'm Ricardo Almeida, a 3rd-year PhD student from the University of Pisa and University of Camerino, both in Italy. I'm in my last year of a national PhD programme on blockchain and distributed ledger technology, the first of its kind in Italy. My research has been primarily centred on remote voting systems, i.e., voting platforms that do not restrict voters geographically, but recently I was able to "convince" my advisors to switch the base technology in which I'm exploring this concept towards the resource-based paradigm exhibited by smart contract programming languages such as Cadence and Move.

The concept in itself is equally exciting and unexplored, and I decided to kill two birds with one carefully planted C-4 charge by exploring it from the point of view of a voting platform. I've been programming and exploring the Flow blockchain and Cadence since early 2022. I was extremely curious and attracted by how radical the resource-based paradigm was when compared to the "traditional" way of representing digital assets in a blockchain context, which is essentially the mapping-based strategy employed in Solidity and related languages. The resource paradigm was far cleaner, more secure and so, so much fun to work with when compared to Solidity. I've been trying to "sell" this approach to my advisor team since then, but unfortunately I had to wait for the rest of the research community to catch on to get any traction worth mentioning.

## What am I working in right now?
One day my main advisor requested a meeting with me. She had gone to an academic conference in 2024, and it turned out that Move and resources were all the rage in there. There were a lot of articles being presented on the topic, and she could see that this paradigm was finally seeping into the academic world. Even though she was only half paying attention whenever I was explaining how Flow and Cadence worked, she understood enough to realise that one of her own students was looking at this for a full 2 years up to that point. Now I look like this awesome visionary, but I had to eat a lot of crow before getting vindicated.

Currently, my research has shifted towards providing a full analysis of the resource-based concept:
- Where did it come from?
- How does it work exactly?
- Who's using it?
- What are the advantages and disadvantages over the ledger-based (e.g., Ethereum) "classical" model?
I'm working on this alongside the development of the first resource-based remote voting platform, which I obviously want to develop in Cadence and Flow.

# The Resource-based Voting Platform
(I don't have a cool name for it yet... :confused:)
The basis of my idea is summarised in the figure below:

<img width="905" height="844" alt="15_Resource_based_enc_framework" src="https://github.com/user-attachments/assets/4345bb2c-45b5-4c9c-8f8e-c80359147dd7" />

From the point of view of other remote voting systems, even blockchain-based ones, there's not a lot added to this approach, given that it is a tried and successful one. The biggest addition from my part is to use resources to abstract ballots as a way to research how these can fare in such a context.

NOTE: From this point onwards, for simplicity's sake, I'm referring to any resource instance in a capitalised fashion. A "Ballot" refers to an instance of a Cadence resource defined through a smart contract and minted using the usual admin-type resource. A "ballot", on the other hand, refers to the general object.

The star of this system is the Ballot resource. I've built this one to emulate a real-world ballot as much as possible (given that resources are inspired by *linear types* and these intend to represent real-world values as well). Just like with real-life ballots, Ballot's ownership is implied from the account owner whose storage they exist at at any point.
Ballots are printed on demand by an authority (the *Election Authority (EA)* in the figure) and delivered to the voter's account upon successful registration/authentication. This emulates a physical voting booth where a voter gets a paper ballot printed by the election organisers after these check that the voter's ID is on an eligibility list.

## System Actors:

- **Voter $$V$$:** The main actor in the system. The registration process gets the voter's identification $$Id_{V}$$, the account address $$V_{A}$$, and inserts this pair in the eligibility list if validated through whatever rules $$EA$$ wishes to impose.

- **Voter Device $$D$$:** Some operations in this system need to happen off-chain. The voter device abstracts the platform used for this purpose. This device can be any kind of computation platform capable of basic cryptographic operations, mainly calculating hash digests and encrypting and decrypting data. Cadence is capable of running hashing algorithms but not encryption/decryption ones. A mobile phone or a laptop is more than capable of the kind of operations that I need done. This is not a technological limitation but has everything to do with the fact that Flow is a public blockchain; therefore, all data on chain is available for public consultation. Performing encryptions and decryptions in public blockchains is highly inadvisable since it is impossible to do such operations without revealing the sensible information, such as the plaintext to encrypt and any private encryption keys involved (they are called "private" for a reason:no_mouth:). Therefore, I need some of this process to happen outside of the Flow chain and in a device capable of running the kind of computations indicated.

- **Election Authority $$EA$$:** Also known as the election administrator, this entity is responsible for creating and distributing encryption keys, validating voters's eligibility, minting new Ballots and computing tallies. Half of the proposed process happens between Flow accounts. On one side I have the voter's individual accounts, and on the other I have $$EA$$'s own account, which is going to be used to store the critical resources for this exercise, namely, the BallotPrinterAdmin and Elections (more on this in a minute).

## Smart Contract Backend

The bulk of the logic suggested is going to be processed through a smart contract backend. But in this resource-based context, smart contracts are more akin to recipe books for resources than logic units, as it is the case for ledger-based blockchains. As such, the contracts deployed in this project are used as standards to create the resources that this process depends on. These are:

- The *BallotStandard* contract that implements the details for Ballots.

- The *ElectionStandard* contract that implements the details for Elections.

- The *VotingBooth* contract (used to define, create, and save the BallotPrinterAdmin. Check [this section](#process-resources) for additional details.

- The *BallotBurner* contract to create a BurnBox resource to allow voters to set unwanted Ballots to be burnt (I'm still figuring out if I really need this resource or not :neutral_face:)

## System Resources

The basis of this system hinges on the following set of resources:

- **Ballot** As I've mentioned before, the Ballot resource is the base element. Its minting is highly regulated by the usual admin printer resource, as has been the case for most resource-based contracts in the Flow blockchain. As a resource, Ballots are fairly simple since they intend to transport the choice of a voter $$V$$ throughout the system. They work as mutable NFTs, which is not a usual concept in ledger-based blockchain, but it is trivial to implement in a resource-based one. The advanced access control system offered by Cadence allows me to build these resources so that only the voter can edit the *option* parameter in their metadata and so that they don't leak any information during the process. Unfortunately, Flow is still a public blockchain, and there is no access control strategy that I can use to completely prevent anyone from reading the information in a Ballot. At the end of the day, all Ballot data goes into the blockchain and can be publicly consulted by checking the block data itself. As such, I have to conceive this system in such a way that voting data never gets into a Ballot as plaintext. More details on this further on.

- **BallotPrinterAdmin** This one is the usual "NFT" printer, and it follows the Cadence convention: this resource is created once and only once during the VoteBooth contract deployment, and it is immediately stored into the *Election Authority (EA)* account. This means that only the EA can run the *printBallot* function to issue a blank Ballot to a given voter $$V$$. All the logic to create *BallotPrinterAdmin* resources is contained in the *VoteBooth* contract constructor, as it is the usual case.

- **Election** This resource is used to abstract a single election exercise. The idea is to establish this system as a modular one, capable of running multiple elections in parallel. The way to do it is to encapsulate the whole exercise in an Election resource. Election creation is limited to the *Election Authority* but since these are not supposed to be saved in any account other than EA's, there's no need to create a minter resource for these ones (though I'm still researching if using an *ElectionMinter* of sorts could be a more practical approach...). Each Election is characterised by a unique ID value $$Id_{E}$$, an *electionName*, an *electionBallot* that contains the question to be answered by the voter, and an *electionOptions* set displaying the options available for the voter to choose from. Elections are, to some extent, *collection-type* resources that can hold other resources, namely, Ballots. They do so through the usual dictionary, but in this case I'm using the hash digest of the voter's identification string $$Id_{V_{i}}$$ as a key, thus storing the Ballots submitted by voters in a fairly private manner (realistically, if the voter leaks his/her identification string, an adversary can use that to retrieve the voter's Ballot information). The actual choice in that Ballot is still protected with encryption, but this possibility does affect the privacy of the voter in a non-insignificant amount. Elections emulate mailboxes in regard to how they store Ballots. I'm using Cadence access control primitives to limit the withdrawal of submitted Ballots to the *Election Authority* alone, this mimicking a regular mailbox: anyone can deposit a letter into it, but once you do, only the mailman with the proper key can withdraw it.

- **VoteBox** This is a collection-type resource that lives in each valid voter's storage account. It is used to simplify the deposit and withdrawal of Ballots from an individual user's storage account. Also, I'm using Cadence's advanced programmatic capabilities to extend the functionalities of the account itself by adding the auxiliary functions that I need to this resource. VoteBoxes are created in a voter's account storage upon successful registration beneath the *Election Authority*. VoteBoxes store blank and filled (but not submitted yet) Ballots in an internal dictionary that uses the ID of the Election that those Ballots are to be used with as a key. This by itself limits VoteBoxes to store one and only one Ballot per Election, which is an easy and practical way to prevent double voting.

## Voting Process

I'm going to describe the expected voting process, as indicated in the [figure](#the-resource-based-voting-platform). The figure is self-explanatory, but it is important to add that every state transition is indicated by an arrow, and it is implemented in the system using Cadence transactions.

1. The voting process begins with a voter registering him/herself with the Election Authority (EA). If deemed eligible, EA adds the voter information to its own internal database. Due to privacy concerns, this process occurs off-chain. The actual details of the registration process depend on the policies and rules that the EA wishes to implement, but in principle, voters only need to register once and then use the authentication process to participate in various elections. A successful registration concludes with the creation and saving of a VoteBox in the voter's storage account. The EA proceeds by creating individual Elections and publishing their details, namely, the $$Id_{E_{j}}$$, the *electionName*, *electionBallot*, and *electionOptions* to inform voters of ongoing elections. A voter $$V_{i}$$ uses the tuple $$(V_{A_{i}}, Id_{V_{i}}, Id_{E_{j}})$$, i.e., the voter account address, his/her identification string, and the id of the Election that the voter wishes to participate in, $$Id_{E_{j}}$$, to authenticate him/herself and request a Ballot to vote in Election $$Id_{E_{j}}$$. Voters use their voting device $$D_{i}$$ to interact with the *VoteBox* in their account's storage to execute the authentication operation.

2. If a voter is deemed eligible to vote in a given Election $$Id_{E_{j}}$$, the EA proceeds by providing the tuple $$(V_{A_{i}}, Id_{E_{j}}, pk)$$ to the *BallotPrinterAdmin* that only EA can interact with. The *BallotPrinterAdmin* mints a blank Ballot $$B_{Id_{B}, Id_{E_{j}}}$$, where $$Id_{B}$$ is the unique identifier for the minted Ballot, and $$Id_{E_{j}}$$ identifies a specific existing Election where this Ballot can be cast. Every Ballot is minted "locked" to a specific Election, which means that it can only be used with the Election identified by $$Id_{E_{j}}$$. Ballots are relatively cheap to produce in Flow, so this strategy is feasible and produces a highly secure system, albeit a bit strict in some senses.

3. The *BallotPrinterAdmin* uses the voter address $$V_{A_{i}}$$ provided to deposit the Ballot $$B_{Id_{B}, Id_{E_{j}}}$$ into voter $$V_{i}$$ VoteBox. This deposit is conditional. If it turns out that the voter's VoteBox already has a Ballot stored under the $$Id_{E_{j}}$$ key, the transaction fails and the blockchain state reverts. To avoid unnecessary creation of Ballots, the *BallotPrinterAdmin* checks the voter's VoteBox first to see if there's a Ballot in there under the provided $$Id_{E_{j}}$$. If one exists already, the transaction fails before a new Ballot is minted.

4. With a blank Ballot in his/her possession, the voter can now vote. But given that his/her choice needs to be encrypted first, the voter chooses a valid option in his/her voting device screen (I'm imagining this as a mobile application), and the voting device does the rest. The Ballot with provided with a public encryption key (pk) created and set upon the Election in question by the EA. The voting device uses this key to obfuscate the option selected by the voter. But since each Election has a finite (and usually small) set of available options, to protect the voter's privacy, I need to add some salt to the encryption, or otherwise it's easy for an adversary to figure out which option a voter has selected if there's only a finite number of ciphertexts submitted in each Election. To that effect, the voting device generates a random integer $$r$$ and concatenates it with the selected option to increase the space of the ciphertext and thus protect the voter's privacy. This salt can, and it is used later in the process as a "tally receipt" to increase the transparency of this process. Details on this receipt process follow shortly.

5. Once a valid option string is produced by the voting device, it continues by setting the Ballot metadata, namely a specific mutable option field, to this choice string. Because this process changes the state of the blockchain, it requires a transaction as well.

6. The Ballot is now ready for submission. The 2 previous points can be repeated by the voter if he/she changes his/her mind before submitting the Ballot, i.e., the voter can edit the Ballot's metadata as many times as he/she wishes until it gets submitted. Submitting a Ballot means depositing it in an Election's internal dictionary (identified in the [figure](#the-resource-based-voting-platform) as the ballots dictionary). Once submitted, the Ballot becomes irrecoverable by the voter. It can be revoked or replaced by another one (details on this to follow as well), but once a Ballot goes into the ballots dictionary of an Election, it can only be withdrawn by the Election Authority during the tally process.

7. Once the voting window for an Election closes, the election is deemed finished, and it no longer accepts any more Ballots. From there, all it needs to do is to wait for the *Election Authority* to invoke the withdrawBallots function. This function returns an array with all the ciphertexts from the submitted Ballots (there's no point in returning the Ballots themselves). They are kind of useless at this point. I'm also making sure these ciphertexts are not returned in any particular order, thus increasing the level of voter privacy one more time, though Cadence is quite explicit in that matter. In the absence of an ordering parameter, processing the Ballots under a Cadence loop does not guarantee any sort of fixed order, as per Cadence documentation, which is more than OK for me.

8. The rest of the process happens off-chain, namely, the decryption of the retrieved ciphertexts by the *Election Authority*, which is the only entity in this process that knows the secret decryption key $$sk$$. After decrypting the ciphertexts, the EA splits the voter options, now completely anonymised, from the random salt r, and it is now able to tally the final count.

9. The election process finishes with the publication of the final results alongside a list of the random salts used in the obfuscation process. This salt list effectively functions as a *tally-as-recorded* verifiability guarantee, which, according to the academic research that I've reviewed, is quite tricky to implement in this kind of voting system. The voter's voting device stores the random salt *r* used to add entropy to the encrypted option, and this value can be used later to assure the voter that his/her vote made it through the process and was correctly tallied. If a voter does not see his/her random salt in the final list, he/she can argue against the validity of the final result (hopefully this should never happen).

### Multiple Ballot Casting
The resource-based context that I'm using, alongside the usage of dictionaries to store Ballots in Elections makes the implementation of a multiple ballot cast feature almost trivial. A voter can change his/her mind after submitting a Ballot, especially if there's a large election window in place. To account for this possibility, I'm allowing voters to submit as many Ballots as they wish since every Ballot submitted is done so under a single and unique $$H(Id_{V_{i}})$$. Dictionaries do not allow for duplicate keys, and voters are, by default, registered under a $$Id_{V_{i}}$$ string that they cannot run from or falsify. Blockchain technology guarantees this to some extent. Therefore, submitting a new Ballot under an existing $$H(Id_{V_{i}})$$ replaces the old one. Because Ballots are resources, and resources are linear types, the old Ballot needs to be explicitly burnt (dealt with in the transaction). Voters can, effectively, submit as many Ballots as they wish during the election period, but only the last one gets counted.

### Ballot Revoking
If needed, this system implements the possibility for a voter to revoke a previously submitted vote by adapting the mechanism depicted in the previous [section](#multiple-ballot-casting). Every new Ballot is minted with a default option set that is not included in the electionOptions set. Yet, Ballots are allowed to be submitted with this option set. Doing so instructs the system to ignore this Ballot for counting. The actual mechanism in which this occurs is still under investigation.
The easier option is to leave this to the criteria of the *Election Authority*. If the EA finds a Ballot with the default option still set, it can simply ignore and discard it. But since the tally process has to happen off-chain (due to the requirements imposed by the encryption logic), there is a loss of transparency at this stage that I wish to avoid. I want voters to trust as little as possible in the third party, i.e., the *Election Authority*, to ensure the consistency of the exercise.
Therefore, I'm considering employing a threshold cryptosystem (such as the ElGamal one) for my encryption needs and then processing potentially revoked Ballots homomorphically by doing comparisons with the default option while still in the ciphertext domain. But I cannot go around avoiding using random salt in this question, which complicates this process greatly. But doing so allows me to burn and revoke Ballots on chain, which can give the voter the necessary guarantees (through the emission of events, for example) that his/her vote was properly revoked.
Since this is not one of the core features of the system, I have this quite low in my priority list, though I want to have a proper look at it at some point.

# What is my "real" objective with this project?
Even though I'm dabbling in the world of remote electronic voting, my "main" purpose with this is not to create a handy and flexible voting system that is only to be used every 4 or 5 years to perpetuate a democratic system that is screaming for reform (more so today than ever). I'm of the opinion that this is a massive waste of my talent and this technology.
With a tool such as this one available to the wider public, I strongly believe that we, as a society, can finally move to a more advanced democratic system, namely one based on choosing policies rather than these armies of uninspired and mediocre politicians that have been being shoved down our collective throats for decades now.

## The Policy-Oriented-Democracy Initiative
I've come up with the *Policy-Oriented-Democracy (POD)* concept as a solution to our current political problems.
What if we had a political party, or even a single politician, that had no position in the left-right political spectrum? A party without a manifesto or flavour of any kind? A political party devoid of all promises... except one: to be completely faithful to the decisions derived from the social consensus. A party that puts the decisions and direction solely in the hands of the people. Any person can participate in this exercise, not just the ones that voted for this party to reach power. We have the technology to make this a reality, and this project is an important step in this direction.

### How does a POD party work, then?
It's actually quite simple: with a tool such as the one suggested in this project, politicians from this party are constantly asking people (again, everyone in a city, district, or country, not just the ones that helped elect them) for their opinion on the matters of the parliament (or equivalent political organ). Normal people use this tool to submit their individual opinions on specific policies, and the party simply votes on the parliament floor according to the aggregated opinion of the voters that participated.
For example, let's imagine that a POD party is part of some countries political systems (parliament, senate, etc.), and one of the other parties suggests a complete privatisation of a public healthcare system. Once this vote is announced, members of the POD party use this system to create an Election whose electionBallot is something along the lines of "Do you want to privatise the healthcare system?" and whose *electionOptions* are the set ["Yes", "No"]. Once created, voters receive an alert about an impending vote and are asked to participate by submitting their opinions using the process depicted [here](#voting-process).
The election window remains open until shortly before the parliamentary vote has to take place. Once the window closes, the POD politicians, which in this case represent the *Election Authority*, tally any submitted Ballots and vote according to whichever option has the most representation. Quite simple, actually.

### Okay, this seems OK but a bit reactive. What can we do to actually change things from our end?
This system is actually just half of my full idea (but it is the one that I can use to get a PhD out of it, so here we are). Alongside this one, I want to create a resource-based suggestion system. This one allows voters to either submit concrete policy suggestions, e.g., free healthcare for everyone, subsidise public education, invest in public housing, etc., as well as vote up or down on policies suggested by other voters. After some time, the expectation is that the most popular policies, i.e., the ones more upvoted, will shift to the top of the preference list. POD politicians and parties periodically check this list, remove the top policy suggestion from it, format it into a concrete policy proposal, and put it to a vote to the rest of the parliament.
This is as close to a direct democratic system that we can achieve at this point in our history. It needs zero reform from current existing systems while simultaneously amplifying the opinions of the people that have to deal with the consequences of parliamentary games.
Maybe this works, maybe it doesn't, but I'm sure going to spend a lot of energy trying.